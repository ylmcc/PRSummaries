"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupAppFactory = void 0;
const node_child_process_1 = require("node:child_process");
const querystring_1 = require("querystring");
const express_1 = __importDefault(require("express"));
const update_dotenv_1 = __importDefault(require("update-dotenv"));
const manifest_creation_js_1 = require("../manifest-creation.js");
const logging_middleware_js_1 = require("../server/logging-middleware.js");
const is_production_js_1 = require("../helpers/is-production.js");
const import_js_1 = require("../views/import.js");
const setup_js_1 = require("../views/setup.js");
const success_js_1 = require("../views/success.js");
const setupAppFactory = (host, port) => async function setupApp(app, { getRouter }) {
    if (!getRouter) {
        throw new Error("getRouter is required to use the setup app");
    }
    const setup = new manifest_creation_js_1.ManifestCreation();
    const pkg = setup.pkg;
    // If not on Glitch or Production, create a smee URL
    if (!(0, is_production_js_1.isProduction)() &&
        !(process.env.PROJECT_DOMAIN ||
            process.env.WEBHOOK_PROXY_URL ||
            process.env.NO_SMEE_SETUP === "true")) {
        await setup.createWebhookChannel();
    }
    const route = getRouter();
    route.use((0, logging_middleware_js_1.getLoggingMiddleware)(app.log));
    printWelcomeMessage(app, host, port);
    route.get("/probot", async (req, res) => {
        const baseUrl = getBaseUrl(req);
        const manifest = setup.getManifest(pkg, baseUrl);
        const createAppUrl = setup.createAppUrl;
        // Pass the manifest to be POST'd
        res.writeHead(200, { "content-type": "text/html" }).end((0, setup_js_1.setupView)({
            name: pkg.name,
            version: pkg.version,
            description: pkg.description,
            createAppUrl,
            manifest,
        }));
    });
    route.get("/probot/setup", async (req, res) => {
        // @ts-expect-error query could be set by a framework, e.g. express
        const { code } = req.query || (0, querystring_1.parse)(req.url?.split("?")[1] || "");
        if (!code || typeof code !== "string" || code.length === 0) {
            res
                .writeHead(400, { "content-type": "text/plain" })
                .end("code missing or invalid");
            return;
        }
        const response = await setup.createAppFromCode(code, {
            // @ts-expect-error
            request: app.state.request,
        });
        // If using glitch, restart the app
        if (process.env.PROJECT_DOMAIN) {
            (0, node_child_process_1.exec)("refresh", (error) => {
                if (error) {
                    app.log.error(error);
                }
            });
        }
        else {
            printRestartMessage(app);
        }
        res
            .writeHead(302, {
            "content-type": "text/plain",
            location: `${response}/installations/new`,
        })
            .end(`Found. Redirecting to ${response}/installations/new`);
    });
    const { WEBHOOK_PROXY_URL, GHE_HOST } = process.env;
    const GH_HOST = `https://${GHE_HOST ?? "github.com"}`;
    const importViewRendered = (0, import_js_1.importView)({
        name: pkg.name,
        WEBHOOK_PROXY_URL,
        GH_HOST,
    });
    route.get("/probot/import", (_req, res) => {
        res
            .writeHead(200, {
            "content-type": "text/html",
        })
            .end(importViewRendered);
    });
    route.post("/probot/import", express_1.default.json(), (req, res) => {
        const { appId, pem, webhook_secret } = req
            .body;
        if (!appId || !pem || !webhook_secret) {
            res
                .writeHead(400, {
                "content-type": "text/plain",
            })
                .end("appId and/or pem and/or webhook_secret missing");
            return;
        }
        (0, update_dotenv_1.default)({
            APP_ID: appId,
            PRIVATE_KEY: `"${pem}"`,
            WEBHOOK_SECRET: webhook_secret,
        });
        res.end();
        printRestartMessage(app);
    });
    const successViewRendered = (0, success_js_1.successView)({ name: pkg.name });
    route.get("/probot/success", (_req, res) => {
        res
            .writeHead(200, { "content-type": "text/html" })
            .end(successViewRendered);
    });
    route.get("/", (_req, res) => res
        .writeHead(302, { "content-type": "text/plain", location: `/probot` })
        .end(`Found. Redirecting to /probot`));
};
exports.setupAppFactory = setupAppFactory;
function printWelcomeMessage(app, host, port) {
    // use glitch env to get correct domain welcome message
    // https://glitch.com/help/project/
    const domain = process.env.PROJECT_DOMAIN ||
        `http://${host ?? "localhost"}:${port || 3000}`;
    [
        ``,
        `Welcome to Probot!`,
        `Probot is in setup mode, webhooks cannot be received and`,
        `custom routes will not work until APP_ID and PRIVATE_KEY`,
        `are configured in .env.`,
        `Please follow the instructions at ${domain} to configure .env.`,
        `Once you are done, restart the server.`,
        ``,
    ].forEach((line) => {
        app.log.info(line);
    });
}
function printRestartMessage(app) {
    app.log.info("");
    app.log.info("Probot has been set up, please restart the server!");
    app.log.info("");
}
function getBaseUrl(req) {
    const protocols = req.headers["x-forwarded-proto"] ||
        // @ts-expect-error based on the functionality of express
        req.socket?.encrypted
        ? "https"
        : "http";
    const protocol = typeof protocols === "string" ? protocols.split(",")[0] : protocols[0];
    const host = req.headers["x-forwarded-host"] || req.headers.host;
    const baseUrl = `${protocol}://${host}`;
    return baseUrl;
}
//# sourceMappingURL=setup.js.map