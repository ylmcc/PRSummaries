"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Probot = void 0;
const lru_cache_1 = require("lru-cache");
const auth_js_1 = require("./auth.js");
const get_log_js_1 = require("./helpers/get-log.js");
const get_probot_octokit_with_defaults_js_1 = require("./octokit/get-probot-octokit-with-defaults.js");
const get_webhooks_js_1 = require("./octokit/get-webhooks.js");
const probot_octokit_js_1 = require("./octokit/probot-octokit.js");
const version_js_1 = require("./version.js");
const server_js_1 = require("./server/server.js");
const rebind_log_js_1 = require("./helpers/rebind-log.js");
class Probot {
    static version = version_js_1.VERSION;
    static defaults(defaults) {
        const ProbotWithDefaults = class extends this {
            constructor(...args) {
                const options = args[0] || {};
                super(Object.assign({}, defaults, options));
            }
        };
        return ProbotWithDefaults;
    }
    webhooks;
    webhookPath;
    log;
    version;
    on;
    onAny;
    onError;
    auth;
    state;
    constructor(options = {}) {
        options.secret = options.secret || "development";
        let level = options.logLevel;
        const logMessageKey = options.logMessageKey;
        this.log = options.log
            ? (0, rebind_log_js_1.rebindLog)(options.log)
            : (0, get_log_js_1.getLog)({ level, logMessageKey });
        // TODO: support redis backend for access token cache if `options.redisConfig`
        const cache = new lru_cache_1.LRUCache({
            // cache max. 15000 tokens, that will use less than 10mb memory
            max: 15000,
            // Cache for 1 minute less than GitHub expiry
            ttl: 1000 * 60 * 59,
        });
        const Octokit = (0, get_probot_octokit_with_defaults_js_1.getProbotOctokitWithDefaults)({
            githubToken: options.githubToken,
            Octokit: options.Octokit || probot_octokit_js_1.ProbotOctokit,
            appId: Number(options.appId),
            privateKey: options.privateKey,
            cache,
            log: (0, rebind_log_js_1.rebindLog)(this.log),
            redisConfig: options.redisConfig,
            baseUrl: options.baseUrl,
        });
        const octokitLogger = (0, rebind_log_js_1.rebindLog)(this.log.child({ name: "octokit" }));
        const octokit = new Octokit({
            request: options.request,
            log: {
                debug: octokitLogger.debug.bind(octokitLogger),
                info: octokitLogger.info.bind(octokitLogger),
                warn: octokitLogger.warn.bind(octokitLogger),
                error: octokitLogger.error.bind(octokitLogger),
            },
        });
        this.state = {
            cache,
            githubToken: options.githubToken,
            log: (0, rebind_log_js_1.rebindLog)(this.log),
            Octokit,
            octokit,
            webhooks: {
                secret: options.secret,
            },
            appId: Number(options.appId),
            privateKey: options.privateKey,
            host: options.host,
            port: options.port,
            webhookPath: options.webhookPath || server_js_1.defaultWebhooksPath,
            request: options.request,
        };
        this.auth = auth_js_1.auth.bind(null, this.state);
        this.webhooks = (0, get_webhooks_js_1.getWebhooks)(this.state);
        this.webhookPath = this.state.webhookPath;
        this.on = this.webhooks.on;
        this.onAny = this.webhooks.onAny;
        this.onError = this.webhooks.onError;
        this.version = version_js_1.VERSION;
    }
    receive(event) {
        this.log.debug({ event }, "Webhook received");
        return this.webhooks.receive(event);
    }
    async load(appFn, options = {}) {
        if (Array.isArray(appFn)) {
            for (const fn of appFn) {
                await this.load(fn);
            }
            return;
        }
        return appFn(this, options);
    }
}
exports.Probot = Probot;
//# sourceMappingURL=probot.js.map